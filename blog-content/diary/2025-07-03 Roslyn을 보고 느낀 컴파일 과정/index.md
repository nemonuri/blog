---
alias: thinking-compile-process-from-roslyn
---

## 토큰화

- 입력
  - 문자열
  - 토큰화 규칙
- 반환
  - 토큰 나열
- 설명
  - 일종의 메모라이징 기법
  - 구문 분석의 성능 향상을 위해, 문자열을 날것 그대로 사용하는 대신, 문자열을 분할해 '토큰 나열'을 만들고, 그 토큰 나열을 구문 분석의 입력으로 사용한다.
  - 즉, '토큰'이 한 단계 위의 '문자'다.

## 구문 분석

- 입력
  - 토큰 나열
  - 구문 분석 규칙
- 반환
  - 구문 트리
- 설명
  - 구문 분석에 대한 이론은 찾아보면 많다. 넘어가자.

## 바인더 포레스트 제작

- 입력
  - 구문 트리
  - 바인더 팩토리
  - 바인더 생성 규칙
- 반환
  - 바인더 포레스트
- 설명
  - '바인더'는 다음 정보를 가진다.
    - 자신과 연결된 구문 노드
    - 자신의 부모 바인더
  - '용도'에 따라, 한 구문 노드가 여러 바인더와 연결될 수 있다.
  - 바인더 포레스트는, (구문 노드, 용도)를 Key로, 바인더를 Value로 하는 '캐시 사전' 이다.

## 의미 모형 제작 1단계

- 입력
  - 구문 트리
  - 바인더 포레스트
  - 의미 모형 0단계
  - 바운드 포레스트 0단계
  - 의미 모형 생성 규칙 0단계
- 반환
  - 의미 모형 1단계
  - 바운드 포레스트 1단계
- 설명
  - '의미 모형 0단계'는 외부 설정값을 통해 만들어진 의미 모형이다.
    - 컴파일러 옵션
    - 프로젝트 설정
    - link할 외부 라이브러리
  - 바운드 포레스트 0단계는 비어 있다.
  - 각 바운드 노드는, 자식 바운드 노드들을 가진다. 부모 바운드 노드는 가지지 않는다.
    - 즉, 바운드 노드는 철저하게 Bottom-Up 방식으로 만든다.
  - 한 바운드 노드는 한 구문 노드와 연결되어 있다.
    - 구문 노드 하나가 둘 이상의 바운드 노드와 연결되는 경우는 없다.
    - 바운드 노드와 연결되지 않은 구문 노드도 존재할 수 있다.
    - (잠깐) 이러면, 한 노드가 여러 바인더와 연결될 수 있다는 주장과 모순 아닌가?
  - 의미 모형 생성 규칙을 통해,
    - 규칙에 따라 구문 노드들을 선택하고,
    - 각 구문 노드에 해당하는 바인더가 알맞은 바운드 노드를 만들고,
    - 각 바운드에서 1단계 의미들을 추출한다.
      - 1단계 의미 추출은, 0단계 의미에 의존한다.
      - 2단계 의미 추출은, 0~1단계 의미에 의존한다.
      - ....

(이런 식으로, 의미 모형 제작 n단계까지 반복)

## 의미 모형 제작 마무리

- 입력
  - 구문 트리
  - 바인더 포레스트
  - 의미 모형 n단계
  - 바운드 포레스트 n단계
- 반환
  - 의미 모형
  - 바운드 트리

## 바운드 트리 Lowering 1단계

- 입력
  - 구문 트리 0단계
  - 바인더 포레스트 0단계
  - 의미 모형 0단계
  - 바운드 트리 0단계
  - lowering 규칙 0단계
- 반환
  - 구문 트리 1단계
  - 바인더 포레스트 1단계
  - 의미 모형 1단계
  - 바운드 트리 1단계
- 설명
  - 어셈블리어에 가까운 방향으로, 바운드 노드의 구문을 바꾼다.

(이런 식으로, 바운드 트리 Lowering n단계까지 반복)


## 바운드 트리 Emit

- 입력
  - 구문 트리 n단계
  - 바인더 포레스트 n단계
  - 의미 모형 n단계
  - 바운드 트리 n단계
  - Emit 규칙 n단계
- 반환
  - 어셈블리 파일

## 거꾸로...?

- 일단, 어셈블리 파일 Rewriting 부터 시작 아닐까
  - 그걸 하려면, 각 언어별 맞춤 assembly 바인딩 규칙을 정하고, 각 언어 순서쌍별 assembly 바운드 트리 다시쓰기 규칙을 정해야겠네.
    - 반대 방향으로도 하나 더.
